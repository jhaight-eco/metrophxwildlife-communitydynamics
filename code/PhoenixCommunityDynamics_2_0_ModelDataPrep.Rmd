---
title: "Metro Phoenix Wildlife Study - Community Dynamics - Model Input Data Preparation"
author: "Jeffrey Haight"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list=ls())
gc()
```

 
```{r packages, include = FALSE}
library(abind)

library(dplyr)
library(ggplot2)
library(ggrepel)
library(beepr)


```

# Import Datasets
```{r import detection data}
# Three seasons of data from the Metro Phoenix Wildlife Study
    y <- readRDS("~/GitHub/metrophxwildlife-communitydynamics/data/model_inputs/y_s22_j50_occ16day_3season.rds")

# the basic sampling stats
    n.site <- dim(y)[1]   # number of sites
    n.survey <- dim(y)[2]  # number of surveys
    n.season <- dim(y)[3]  # number of seasons
    n.spp <- dim(y)[4]     # number of species
    
    
# Site survey effort
    K <- read.csv("~/GitHub/metrophxwildlife-communitydynamics/data/model_inputs/K_tot_j50_3season.csv", header = T)
    K$effort <- K$season1 +K$season2 + K$season3
  

# Put the data into a collapsed format, with number of by-survey detections
  # this will make it easier to calculate likelihood and reduce the dimensions of the input data (though it creates a new input)
  # number of full surveys of each camera in each seasons
  # same number of surveys per species, so just select the first species
  #K.survey <- apply(y, c(1,3,4), function(x) length(which(!is.na(x))))[,,1]  
  K.survey <- apply(y[,,,1], c(1,3), function(x) length(which(!is.na(x))))
  
  ysum <- apply(y, c(1,3,4), function(x) sum(x, na.rm = TRUE))
  #ysum[,2,]
```

```{r import site covariate data}

# Site covariate data
data.site <- read.csv("~/GitHub/metrophxwildlife-communitydynamics/data/model_inputs/covariates_50camsite.csv") %>% arrange(site)


  # add survey effort columns
  #data.site$K_days <- c(K_wd, K_ww, K_cw)    # number of surveyed days
  
  #data.site$effort <- K_days/max(K_days)     
  
  #data.site <- data.site %>%
  #  group_by(season) %>%
  #  mutate(
  #    effort = K_days/max(K_days)        # proportion of days in each season that were surveyed
  #  )
  
  # add quadratic urbanization terms
  data.site$impquad100m  <- ((data.site$imp100m - mean(data.site$imp100m))/sd(data.site$imp100m))^2
  data.site$impquad1km  <- ((data.site$imp1km - mean(data.site$imp1km))/sd(data.site$imp1km))^2
  data.site$impquad5km  <- ((data.site$imp5km - mean(data.site$imp5km))/sd(data.site$imp5km))^2

  # standardize all covariates by season
  # some of these don't actually vary by season (e.g. imperviousness), but they can be standardized here anyway
  data.site <- data.site %>%
          #group_by(season) %>%
          mutate(
            imp100m_std = (imp100m - mean(imp100m))/sd(imp100m),
            imp1km_std = (imp1km - mean(imp1km))/sd(imp1km),
            imp5km_std = (imp5km - mean(imp5km))/sd(imp5km),
            sdhi100m_std = (sdhi100m - mean(sdhi100m))/sd(sdhi100m),
            sdhi1km_std = (sdhi1km - mean(sdhi1km))/sd(sdhi1km),
            sdhi5km_std = (sdhi5km - mean(sdhi5km))/sd(sdhi5km),
            pd100m_std = (pd100m - mean(pd100m))/sd(pd100m),
            pd1km_std = (pd1km - mean(pd1km))/sd(pd1km),
            pd5km_std = (pd5km - mean(pd5km))/sd(pd5km),
            #ndvi100m_std = (ndvi_100m - mean(ndvi_100m))/sd(ndvi_100m),
            #ndvi1km_std = (ndvi_1km - mean(ndvi_1km))/sd(ndvi_1km),
            #ndvi5km_std = (ndvi_5km - mean(ndvi_5km))/sd(ndvi_5km)#,
            #ndvisd100m_std = (ndvi_sd_100m - mean(ndvi_sd_100m))/sd(ndvi_sd_100m),
            #ndvisd1km_std = (ndvi_sd_1km - mean(ndvi_sd_1km))/sd(ndvi_sd_1km),
            #ndvisd5km_std = (ndvi_sd_5km - mean(ndvi_sd_5km))/sd(ndvi_sd_5km),
            #effort_std = (effort - mean(effort))/sd(effort)
          )

  # NDVI standardized across seasons
  # For the DCMs, season is not treated as a fixed effect, so covariate effects are not assumed 
  # i.e. we only get one beta estimate for psi1/phi/gamma across all the seasons, 
  # so, for ease of interpretation time-varying variables should be standardized across seasons
  # but, the model is structured to take these season-varying covariates in the form of a matrix
  ndvi.100m.std <- data.site %>% 
    transmute(
      ndvi_wd_std = (ndvi_wd100m - mean(c(ndvi_wd100m, ndvi_ww100m, ndvi_cw100m)))/sd(c(ndvi_wd100m, ndvi_ww100m, ndvi_cw100m)),
      ndvi_ww_std = (ndvi_ww100m - mean(c(ndvi_wd100m, ndvi_ww100m, ndvi_cw100m)))/sd(c(ndvi_wd100m, ndvi_ww100m, ndvi_cw100m)),
      ndvi_cw_std = (ndvi_cw100m - mean(c(ndvi_wd100m, ndvi_ww100m, ndvi_cw100m)))/sd(c(ndvi_wd100m, ndvi_ww100m, ndvi_cw100m))
    )
  mean(as.matrix(ndvi.100m.std))   # mean across seasons
  mean(ndvi.100m.std[,1])
  mean(ndvi.100m.std[,2])
  mean(ndvi.100m.std[,3])
  
  ndvi.1km.std <- data.site %>% 
    transmute(
      ndvi_wd_std = (ndvi_wd1km - mean(c(ndvi_wd1km, ndvi_ww1km, ndvi_cw1km)))/sd(c(ndvi_wd1km, ndvi_ww1km, ndvi_cw1km)),
      ndvi_ww_std = (ndvi_ww1km - mean(c(ndvi_wd1km, ndvi_ww1km, ndvi_cw1km)))/sd(c(ndvi_wd1km, ndvi_ww1km, ndvi_cw1km)),
      ndvi_cw_std = (ndvi_cw1km - mean(c(ndvi_wd1km, ndvi_ww1km, ndvi_cw1km)))/sd(c(ndvi_wd1km, ndvi_ww1km, ndvi_cw1km))
    )
  mean(ndvi.1km.std[,1])
  mean(ndvi.1km.std[,2])
  mean(ndvi.1km.std[,3])
  
  ndvi.5km.std <- data.site %>% 
    transmute(
      ndvi_wd_std = (ndvi_wd5km - mean(c(ndvi_wd5km, ndvi_ww5km, ndvi_cw5km)))/sd(c(ndvi_wd5km, ndvi_ww5km, ndvi_cw5km)),
      ndvi_ww_std = (ndvi_ww5km - mean(c(ndvi_wd5km, ndvi_ww5km, ndvi_cw5km)))/sd(c(ndvi_wd5km, ndvi_ww5km, ndvi_cw5km)),
      ndvi_cw_std = (ndvi_cw5km - mean(c(ndvi_wd5km, ndvi_ww5km, ndvi_cw5km)))/sd(c(ndvi_wd5km, ndvi_ww5km, ndvi_cw5km))
    )
  
  mean(ndvi.5km.std[,1])
  mean(ndvi.5km.std[,2])
  mean(ndvi.5km.std[,3])
  
  # NDVI standardized by season
  # for the meta-analysis model, season is a fixed effect (essentially on model for each season)
    ndvi.100m.std.byseason <- data.site %>%
      transmute(
        ndvi_wd_std = (ndvi_wd100m - mean(ndvi_wd100m))/sd(ndvi_wd100m),
        ndvi_ww_std = (ndvi_ww100m - mean(ndvi_ww100m))/sd(ndvi_ww100m),
        ndvi_cw_std = (ndvi_cw100m - mean(ndvi_cw100m))/sd(ndvi_cw100m)
      )
    ndvi.1km.std.byseason <- data.site %>%
      transmute(
        ndvi_wd_std = (ndvi_wd1km - mean(ndvi_wd1km))/sd(ndvi_wd1km),
        ndvi_ww_std = (ndvi_ww1km - mean(ndvi_ww1km))/sd(ndvi_ww1km),
        ndvi_cw_std = (ndvi_cw1km - mean(ndvi_cw1km))/sd(ndvi_cw1km)
      )
    ndvi.5km.std.byseason <- data.site %>%
      transmute(
        ndvi_wd_std = (ndvi_wd5km - mean(ndvi_wd5km))/sd(ndvi_wd5km),
        ndvi_ww_std = (ndvi_ww5km - mean(ndvi_ww5km))/sd(ndvi_ww5km),
        ndvi_cw_std = (ndvi_cw5km - mean(ndvi_cw5km))/sd(ndvi_cw5km)
      )
    
# Standardize survey covariates 
    # similar to NDVI, there is only one beta across seasons
    # But, detection probability (and the effect of survey effort on it) is not modeled as varying among seasons, 
    # so we don't need to standardize by season
    # column 'effort' = number of days that a site was sampled
    K$effort_std <- (K$effort - mean(K$effort))/sd(K$effort)
    
    K.std <- data.frame(K) %>% 
      transmute(
        k1.std = (season1 - mean(season1))/sd(season1),
        k2.std = (season2 - mean(season2))/sd(season2),
        k3.std = (season3 - mean(season3))/sd(season3)
      ) %>% as.matrix()
```
```{r species covariate data}
# Species Covariates
        data.spp <- read.csv("~/GitHub/metrophxwildlife-communitydynamics/data/model_inputs/EltonTraits_22mammalbird.csv") %>%
                  arrange(name_short)  # this is the column on which the data is all ordered
        
# create new data columns astandardized versions
    # BodyMass.Value = average adult body mass for each species
    # logmass = log-transformed average body mass
    # pc_carn = carnivory, the percentage of diet consisting of vertebrate prey
    

# Create columns for standardized species traits
        data.spp <- data.spp %>%   # standardize body mass
          mutate(BodyMass_std = (BodyMass.Value -mean(BodyMass.Value))/sd(BodyMass.Value),
                logmass_std = (logmass - mean(logmass))/sd(logmass),
                carn_std = (pc_carn - mean(pc_carn))/sd(pc_carn),
                dietdiv_std = (dietdiv - mean(dietdiv))/sd(dietdiv)) %>%
          arrange(name_short)   
        
        
# Common names for the species
names.common <- data.spp$name
names.short <- dimnames(y)[[4]]  # these are the names by which the occupancy data is alphabetized
names.short <- data.spp$name     # same thing


data.spp %>% arrange(dietdiv)

# Look the collinearity of the species traits
cor(data.spp$logmass, data.spp$dietdiv)   # -0.47 isn't too strong
ggplot(data.spp, aes(x = logmass, y = dietdiv)) +
  theme_bw() +
  geom_point()+
  geom_text_repel(aes(label = Species)) +
  labs(x = "Body Mass (kg)", y = "Diet Diversity")+
  scale_x_continuous(trans = "log10", breaks = log10(c(0.1, 1, 10)*1000), labels = c("0.1","1", "10"))      
```
```{r summarize naive richness}
ysum01 <- ysum
ysum01[ysum01 > 1] <- 1
str(ysum01)

data.site$rich_obs_wd <- apply(ysum01[,1,], c(1), function(x) sum(x, na.rm = T))
data.site$rich_obs_ww <- apply(ysum01[,2,], c(1), function(x) sum(x, na.rm = T))
data.site$rich_obs_cw <- apply(ysum01[,3,], c(1), function(x) sum(x, na.rm = T))
```
# Export Model Input Data
```{r}
# Remove any objects from the environment that aren't necessary to run the models
# e.g.
rm(ysum01)

save.image("~/GitHub/metrophxwildlife-communitydynamics/data/model_inputs/ModelInputData_DCM.RData")
```

# Visualize Naive (Observed) Species Richness vs. Environmental Covariates
This is mainly as a preview of the relationships that will be assessed once imperfect detection has been accounted for in the estimates of species richness. Since these are pairwise correlations, the collinearity among the covariates is not being accounted for and these should be taken with a big grain of salt. Certain relationships might not show as significant (e.g., richness vs. heterogeneity) because they are being overshadowed by the stronger relationships (e.g., richness vs. urbanization).

### Richness vs. Urbanization
Unsurprisingly, richness is negatively correlated with urbanization across all seasons. It does also appear as if there are substantial among-season differences in richness, even at low urbanization sites 
```{r}
ggplot(data = data.site)+
  theme_classic() +
  stat_smooth(aes(x = imp1km, y = rich_obs_wd), fill = "green4", col = "green4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = imp1km, y = rich_obs_wd), col = "green4")+
  stat_smooth(aes(x = imp1km, y = rich_obs_ww), fill = "red4", col = "red4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = imp1km, y = rich_obs_ww), col = "red4")+
  stat_smooth(aes(x = imp1km, y = rich_obs_cw), fill = "blue4", col = "blue4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = imp1km, y = rich_obs_cw), col = "blue4") +
  coord_cartesian(ylim = c(0,12.5))
cor(data.site$imp1km, data.site$rich_obs_wd)
cor(data.site$imp1km, data.site$rich_obs_ww)
cor(data.site$imp1km, data.site$rich_obs_cw)
```

### Richness vs. Landscape Heterogeneity
Generally this shows a weak but positive relationship, though the extremely high values seem to be dragging the curve downward
```{r}
ggplot(data = data.site)+
  theme_classic() +
  stat_smooth(aes(x = sdhi5km, y = rich_obs_wd), fill = "green4", col = "green4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = sdhi5km, y = rich_obs_wd), col = "green4")+
  stat_smooth(aes(x = sdhi5km, y = rich_obs_ww), fill = "red4", col = "red4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = sdhi5km, y = rich_obs_ww), col = "red4")+
  stat_smooth(aes(x = sdhi5km, y = rich_obs_cw), fill = "blue4", col = "blue4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = sdhi5km, y = rich_obs_cw), col = "blue4") +
  coord_cartesian(ylim = c(0,12.5))
cor(data.site$sdhi5km, data.site$rich_obs_wd)
cor(data.site$sdhi5km, data.site$rich_obs_ww)
cor(data.site$sdhi5km, data.site$rich_obs_cw)
```
### Richness vs. Vegetation Greenness
```{r}
ggplot(data = data.site)+
  theme_classic() +
  stat_smooth(aes(x = ndvi_wd1km, y = rich_obs_wd), fill = "green4", col = "green4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = ndvi_wd1km, y = rich_obs_wd), col = "green4")+
  stat_smooth(aes(x = ndvi_ww1km, y = rich_obs_ww), fill = "red4", col = "red4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = ndvi_ww1km, y = rich_obs_ww), col = "red4")+
  stat_smooth(aes(x = ndvi_cw1km, y = rich_obs_cw), fill = "blue4", col = "blue4",
              method = "lm", formula = y ~ x + I(x^2)) +
  geom_point(aes(x = ndvi_cw1km, y = rich_obs_cw), col = "blue4") +
  coord_cartesian(ylim = c(0,12.5))
cor(data.site$ndvi_wd1km, data.site$rich_obs_wd)
cor(data.site$ndvi_ww1km, data.site$rich_obs_ww)
cor(data.site$ndvi_cw1km, data.site$rich_obs_cw)
```
